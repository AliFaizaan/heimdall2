const DATA_NOT_FOUND_MESSAGE: string = "N/A";
const NUMBER_NOT_FOUND: number = -1;

/*
Compendium of changes from base store, aside from the obvious:
"impact" of a control is no longer a string, but a number. Cast it yourself
"profile" attribute of a control is now referred to as profile_name. It will by default fetch its "owner" object name, unless one does not exist,
    in which case it will use the autogenerated one via the old method
various properties have been made getters to prevent invalid state configurations, EX where a control property is modified but other related properties remain unchanged.

TODO: Remove DATA_NOT_FOUND_MESSAGE and replace with the more sensible `undefined`
*/

// These types are used throughout for control/result status and impact
export type ControlStatus =
    | "Passed"
    | "Failed"
    | "Not Applicable"
    | "Not Reviewed"
    | "Profile Error";
export type ResultStatus = "passed" | "failed" | "skipped" | "error";
export type Severity = "none" | "low" | "medium" | "high" | "critical";
export type ControlTags = { [key:string]: any};

var _uniqueCtr: number = 0;
function genUniqueID(): number {
    _uniqueCtr += 1;
    return _uniqueCtr;
}

/**
 *  Contains the result(s) of running one or more inspec profiles 
 */
export class InspecOutput {
    version: string;
    platform: string;
    controls: Control[];
    profiles: Profile[];

    /** TODO: We don't currently properly handle these */
    other_checks: any[];
    statistics: any;

    /** Uniquely identify this object for later recall. */
    unique_id: number = genUniqueID();

    constructor(jsonObject: any) {
        // No parent; this is a top level type
        // Abbreviate our param to make this nicer looking
        let o = jsonObject;

        // Save these to properties
        this.version = o.version || DATA_NOT_FOUND_MESSAGE;
        this.platform = o.platform || DATA_NOT_FOUND_MESSAGE;
        this.controls = (o.controls || []).map(
            (c: any) => new Control(this, c)
        );
        this.profiles = (o.profiles || []).map(
            (p: any) => new Profile(this, p)
        );
        this.other_checks = o.other_checks || [];
        this.statistics = o.statistics || {};
    }
}

/** The data of an inspec profile. May contain results, if it was part of a run */
export class Profile {
    parent: InspecOutput | null;
    attributes: Attribute[];
    controls: Control[];
    copyright: string;
    copyright_email: string;
    depends: string;
    generator_name: string;
    generator_version: string;
    groups: Group[];
    license: string;
    maintainer: string;
    name: string;
    sha256: string;
    summary: string;
    supports: string;
    title: string;
    version: string;

    /** Uniquely identify this object for later recall. */
    unique_id: number = genUniqueID();

    constructor(parent: InspecOutput | null, jsonObject: any) {
        // Save our parent. Would be of type InspecOutput
        // Note: can be null, in case of loading a profile independently
        this.parent = parent;

        // Abbreviate our param to make this nicer looking
        let o = jsonObject;

        // These we assign immediately
        this.copyright = o.copyright || DATA_NOT_FOUND_MESSAGE;
        this.copyright_email = o.copyright_email || DATA_NOT_FOUND_MESSAGE;

        // These we break out of their nesting. Generator isn't guaranteed to be there
        this.generator_name =
            (o.generator && o.generator.name) || DATA_NOT_FOUND_MESSAGE;
        this.generator_version =
            (o.generator && o.generator.version) || DATA_NOT_FOUND_MESSAGE;

        this.depends = o.depends || DATA_NOT_FOUND_MESSAGE;
        this.license = o.license || DATA_NOT_FOUND_MESSAGE;
        this.maintainer = o.maintainer || DATA_NOT_FOUND_MESSAGE;
        this.name = o.name || DATA_NOT_FOUND_MESSAGE;
        this.sha256 = o.sha256 || DATA_NOT_FOUND_MESSAGE;
        this.summary = o.summary || DATA_NOT_FOUND_MESSAGE;
        this.supports = o.supports || DATA_NOT_FOUND_MESSAGE;
        this.title = o.title || DATA_NOT_FOUND_MESSAGE;
        this.version = o.version || DATA_NOT_FOUND_MESSAGE;

        // Get controls, groups, and attributes.
        this.controls = (o.controls || []).map(
            (c: any) => new Control(this, c)
        );
        this.groups = (o.groups || []).map((g: any) => new Group(this, g));
        this.attributes = (o.attributes || []).map(
            (a: any) => new Attribute(this, a)
        );
    }
}

/** 
 * Represents an inspec control.
 * 
 * May or not contain results, depending on if this was loaded from an Inspec Result, or just an Inspec Profile.
 */
export class Control {
    /** The Profile or InspecOutput from which this Control was taken */
    parent: Profile | InspecOutput;
    /** 
     * The raw source code of the control. 
     * Note that if this is an overlay control, it does not include the underlying source code
     */
    code: string;

    /** The ID of this control. */
    id: string;

    /** 
     * The impact of this control, as a number ranging. from 0 to 1.0  
     * [0, 0.01) => No impact
     * [0.01, 0.4) => Low impact
     * [0.4, 0.7) => Medium impact
     * [0.7, 0.9) => High impact
     * [0.9, 1.0] => Critical impact
     * */
    impact: number;

    /**
     * A string that essentially acts as a user-facing log of the results of the success/failure of each
     * part of the control's code.
     * This variable is UNSTABLE and should not be used as a ground-truth for testing, as it's format may be changed
     * in the future.
     */
    message: string;

    /**
     * A list of all results of the controls describe blocks.
     * 
     * For instance, if in the controls code we had the following:
     * describe sshd_config do
        its('Port') { should cmp 22 }
     * end
     * 
     * The result of this block as a ControlResult would be appended to the results list.
     */
    results: ControlResult[];

    /** The rule title. */
    rule_title: string;

    /** The path to the source file that this rule originates from. */
    source_file: string;

    /** The line number in the source file that this rule originates from. */
    source_line: number;

    /** 
     * The tags on this control. 
     * Note that this data can essentially take any form.
     * No tags are specifically guaranteed to exist.
     */
    tags: ControlTags;

    /** The description of the vulnerability that this control checks for. */
    vuln_discuss: string;

    /** TODO: We don't currently "properly" handle refs - there's probably something we ought to do with it */
    refs: any[];

    /** Uniquely identify this object for later recall. */
    unique_id: number = genUniqueID();

    constructor(parent: Profile | InspecOutput, jsonObject: any) {
        // Set the parent.
        this.parent = parent;

        // Abbreviate our param to make this all nicer looking
        let o = jsonObject;

        // Save and rename data to match what was in store
        this.code = o.code || DATA_NOT_FOUND_MESSAGE;
        this.id = o.id || DATA_NOT_FOUND_MESSAGE;
        this.impact = (o.impact === undefined) ? NUMBER_NOT_FOUND : o.impact;
        this.refs = o.refs || DATA_NOT_FOUND_MESSAGE;

        // We map results out to ControlResult s
        this.results = (o.results || []).map(
            (r: any) => new ControlResult(this, r)
        ); // Map these to results
        this.rule_title = o.title || DATA_NOT_FOUND_MESSAGE;

        // We break these out. o.source_location may be null
        this.source_file =
            (o.source_location && o.source_location.ref) ||
            DATA_NOT_FOUND_MESSAGE;
        this.source_line =
            (o.source_location && o.source_location.line) || NUMBER_NOT_FOUND;

        // We broke this into a sub-object for modularity
        this.tags = o.tags || {};
        this.vuln_discuss = o.desc || DATA_NOT_FOUND_MESSAGE;

        // Compose our message
        this.message =
            this.impact == 0
                ? this.vuln_discuss + "\n\n"
                : DATA_NOT_FOUND_MESSAGE; // We only put the vuln discuss
        this.results.forEach(r => (this.message += r.toMessageLine()));
    }

    /**
     * TODO: Document
     */
    get vuln_num(): string {
        // We truncate the id based up to its first decimal (as far as I can tell - update later)
        if (this.id.match(/\d+\.\d+/)) {
            let match = this.vuln_num.match(/\d+(\.\d+)*/);
            if (match) {
                return match[0];
            }
        }
        return this.id;
    }

    /**
     * Returns a user-facing representation of the result of this status, consisting of a message explaining
     * this controls status, followed by the contents of this.message.
     */
    get finding_details(): string {
        let result = "";
        switch (this.status) {
            case "Failed":
                return (
                    "One or more of the automated tests failed or was inconclusive for the control \n\n " +
                    this.message +
                    "\n"
                );
            case "Passed":
                return (
                    "All Automated tests passed for the control \n\n " +
                    this.message +
                    "\n"
                );
            case "Not Reviewed":
                return (
                    "Automated test skipped due to known accepted condition in the control : \n\n" +
                    this.message +
                    "\n"
                );
            case "Not Applicable":
                return "Justification: \n\n" + this.message + "\n";
            case "Profile Error":
                if (this.message) {
                    return "Exception: \n\n" + this.message + "\n";
                } else {
                    return "No test available for this control";
                }
            default:
                throw "Error: invalid status generated";
        }
    }

    /** 
     * Returns the control status as computed for the entire control.
     * This is computed as follows:
     * If the profile has 0 impact, it is "Not Applicable"
     * Else, if it contains a "failed" amidst its status list, it is "Failed"
     * Else, if it contains a "passed" amidst its status list, it is "Passed"
     * Else, if it contains a "skipped" amidst its status list, it is "Not Reviewed" 
     * Else, there are no results, and so the profile is marked as "Profile Error" 
     */
    get status(): ControlStatus {
        if (this.status_list.includes("error")) {
            return "Profile Error";
        } else {
            if (this.impact == 0) {
                return "Not Applicable";
            } else if (this.status_list.includes("failed")) {
                return "Failed";
            } else if (this.status_list.includes("passed")) {
                return "Passed";
            } else if (this.status_list.includes("skipped")) {
                return "Not Reviewed";
            } else {
                return "Profile Error";
            }
        }
    }

    /** Compute the severity of this report as a string */
    get severity(): Severity {
        if (this.impact < 0.1) {
            return "none";
        } else if (this.impact < 0.4) {
            return "low";
        } else if (this.impact < 0.7) {
            return "medium";
        } else if (this.impact < 0.9) {
            return "high";
        } else {
            return "critical";
        }
    }

    /** Returns the programatically determined profile name of this control */
    get profile_name(): string {
        let prefix;
        if (this.parent instanceof InspecOutput) {
            // It's a result - name as such
            prefix = "result;";
        } else {
            prefix = "profile;";
        }
        return prefix + this.rule_title + ": " + this.parent.version;
    }

    /** Returns the start time of this control's run, as determiend by the time of the first test*/
    get start_time(): string {
        if (this.results) {
            return this.results[0].start_time;
        } else {
            return DATA_NOT_FOUND_MESSAGE;
        }
    }

    /** Returns the results of this control's `describe` blocks as a list. */
    get status_list(): ResultStatus[] {
        return this.results.map(r => r.status);
    }
}


/** 
 * Holds the results of a describe block inside of single control.  
 */
export class ControlResult {
    /** The Control that this result came from. */
    parent: Control;

    /** The error message of this control, if one occurred  */
    backtrace: string;

    /** TODO: Document what exactly this is */
    code_desc: string;

    /** The ruby exception that this block produced, if any */
    exception: any;

    /**
     * A string that essentially acts as a user-facing description of the success/failure of this block, and what it implies.
     * This variable is UNSTABLE and should not be used as a ground-truth for testing, as it's format may be changed
     */
    message: string;

    /** 
     * A string explaining why this message was skipped (if it was skipped at all).
     * Note that even if the block was skipped, this message is not guaranteed to exist.
     */
    skip_message: string;

    /** An ISO formatted (TODO: Verify this) timestamp of the time that this describe block was run */
    start_time: string;

    /** The status/result of this block */
    status: ResultStatus;

    constructor(parent: Control, jsonObject: any) {
        // Set the parent.
        this.parent = parent;

        // Abbreviate our param to make this all nicer looking
        let o = jsonObject;

        // Rest we copy more or less as normal
        this.backtrace = o.backtrace || DATA_NOT_FOUND_MESSAGE;
        this.code_desc = o.code_desc || DATA_NOT_FOUND_MESSAGE;
        this.exception = o.exception || DATA_NOT_FOUND_MESSAGE;
        this.message = o.message || DATA_NOT_FOUND_MESSAGE;
        this.skip_message = o.skip_message || DATA_NOT_FOUND_MESSAGE;
        this.start_time = o.start_time || DATA_NOT_FOUND_MESSAGE;
        this.status = o.status || DATA_NOT_FOUND_MESSAGE;
    }

    /** 
     * A helper function to converting this to a message line in the Control.message property.
     * Useful for logging.
     * This variable is UNSTABLE and should not be used as a ground-truth for testing, as it's format may be changed
     */
    toMessageLine(): string {
        switch (this.status) {
            case "skipped":
                return "SKIPPED -- " + this.skip_message + "\n";
            case "failed":
                return (
                    "FAILED -- Test: " +
                    this.code_desc +
                    "\nMessage: " +
                    this.message +
                    "\n"
                );
            case "passed":
                return "PASSED -- " + this.code_desc + "\n";
            case "error":
                return (
                    "ERROR -- Test: " +
                    this.code_desc +
                    "\nMessage: " +
                    this.message +
                    "\n"
                );
            default:
                return "Exception: " + this.exception + "\n";
        }
    }
}

/** Contains information regarding the grouping of a controls within a profile */
export class Group {
    /** The profile that defined this group */
    parent: Profile;

    /** The group's title */
    title: string;

    /** A list of control id's contained within this group */
    controls: string[];

    /** The group's id */
    id: string;

    constructor(parent: Profile, jsonObject: any) {
        // Set the parent.
        this.parent = parent;

        // Abbreviate our param to make this all nicer looking
        let o = jsonObject;

        this.title = o.title || DATA_NOT_FOUND_MESSAGE;
        this.controls = o.controls || [];
        this.id = o.id || DATA_NOT_FOUND_MESSAGE;
    }

    // TODO: Make a helper function to grab the actual controls via routing thru parent. Might be nice
}

/** Contains information about a profile's inputs */
export class Attribute {
    /** The profile that defined/uses this attribute/input */
    parent: Profile;

    /** The name of this attribute/input */
    name: string;

    /** 
     * A description of the options for this input.
     * E.G. might state that it takes a number, a file, etc.
     */
    options_description: string;

    /** The default value for this attribute/input */
    options_default: string;

    constructor(parent: Profile, jsonObject: any) {
        // Set the parent.
        this.parent = parent;

        // Abbreviate our param to make this all nicer looking
        let o = jsonObject;

        // Extract rest from json
        this.name = o.name;
        if (o.options) {
            this.options_description =
                o.options.description || DATA_NOT_FOUND_MESSAGE;
            this.options_default = o.options.default || DATA_NOT_FOUND_MESSAGE;
        } else {
            this.options_description = DATA_NOT_FOUND_MESSAGE;
            this.options_default = DATA_NOT_FOUND_MESSAGE;
        }
    }
}
