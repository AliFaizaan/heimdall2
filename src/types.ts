const DATA_NOT_FOUND_MESSAGE: string = "N/A";
const NUMBER_NOT_FOUND: number = -1;

/*
Compendium of changes from base store, aside from the obvious:
"impact" of a control is no longer a string, but a number. Cast it yourself
"profile" attribute of a control is now referred to as profile_name. It will by default fetch its "owner" object name, unless one does not exist,
    in which case it will use the autogenerated one via the old method
various properties have been made getters to prevent invalid state configurations, EX where a control property is modified but other related properties remain unchanged.


*/

// These types are used throughout for control/result status and impact
export type ControlStatus =
    | "Passed"
    | "Failed"
    | "Not Applicable"
    | "Not Reviewed"
    | "Profile Error";
export type ResultStatus = "passed" | "failed" | "skipped" | "error";
export type Severity = "none" | "low" | "medium" | "high" | "critical";

var _uniqueCtr: number = 0;
function genUniqueID(): number {
    _uniqueCtr += 1;
    return _uniqueCtr;
}

export class InspecOutput {
    /* Contains the result(s) of running one or more inspec profiles */
    version: string;
    platform: string;
    controls: Control[];
    profiles: Profile[];

    // TODO: We don't currently properly handle these
    other_checks: any[];
    statistics: any;

    // Uniquely identify this object for later recall.
    unique_id: number = genUniqueID();

    constructor(jsonObject: any) {
        // No parent; this is a top level type
        // Abbreviate our param to make this nicer looking
        let o = jsonObject;

        // Save these to properties
        this.version = o.version || DATA_NOT_FOUND_MESSAGE;
        this.platform = o.platform || DATA_NOT_FOUND_MESSAGE;
        this.controls = (o.controls || []).map(
            (c: any) => new Control(this, c)
        );
        this.profiles = (o.profiles || []).map(
            (p: any) => new Profile(this, p)
        );
        this.other_checks = o.other_checks || [];
        this.statistics = o.statistics || {};
    }
}

export class Profile {
    /* The data of an inspec profile. May contain results, if it was part of a run */
    parent: InspecOutput | null;
    attributes: Attribute[];
    controls: Control[];
    copyright: string;
    copyright_email: string;
    depends: string;
    generator_name: string;
    generator_version: string;
    groups: Group[];
    license: string;
    maintainer: string;
    name: string;
    sha256: string;
    summary: string;
    supports: string;
    title: string;
    version: string;

    // Uniquely identify this object for later recall.
    unique_id: number = genUniqueID();

    constructor(parent: InspecOutput | null, jsonObject: any) {
        // Save our parent. Would be of type InspecOutput
        // Note: can be null, in case of loading a profile independently
        this.parent = parent;

        // Abbreviate our param to make this nicer looking
        let o = jsonObject;

        // These we assign immediately
        this.copyright = o.copyright || DATA_NOT_FOUND_MESSAGE;
        this.copyright_email = o.copyright_email || DATA_NOT_FOUND_MESSAGE;

        // These we break out of their nesting. Generator isn't guaranteed to be there
        this.generator_name =
            (o.generator && o.generator.name) || DATA_NOT_FOUND_MESSAGE;
        this.generator_version =
            (o.generator && o.generator.version) || DATA_NOT_FOUND_MESSAGE;

        this.depends = o.depends || DATA_NOT_FOUND_MESSAGE;
        this.license = o.license || DATA_NOT_FOUND_MESSAGE;
        this.maintainer = o.maintainer || DATA_NOT_FOUND_MESSAGE;
        this.name = o.name || DATA_NOT_FOUND_MESSAGE;
        this.sha256 = o.sha256 || DATA_NOT_FOUND_MESSAGE;
        this.summary = o.summary || DATA_NOT_FOUND_MESSAGE;
        this.supports = o.supports || DATA_NOT_FOUND_MESSAGE;
        this.title = o.title || DATA_NOT_FOUND_MESSAGE;
        this.version = o.version || DATA_NOT_FOUND_MESSAGE;

        // Get controls, groups, and attributes.
        this.controls = (o.controls || []).map(
            (c: any) => new Control(this, c)
        );
        this.groups = (o.groups || []).map((g: any) => new Group(this, g));
        this.attributes = (o.attributes || []).map(
            (a: any) => new Attribute(this, a)
        );
    }
}

export class Control {
    /* The data of an inspec control. May contain results, if it was part of a run */
    parent: Profile | InspecOutput;
    code: string;
    id: string;
    impact: number;
    message: string;
    results: ControlResult[];
    rule_title: string;
    source_file: string;
    source_line: number;
    tags: ControlTags;
    vuln_discuss: string;

    // TODO: We don't currently "properly" handle refs - there's probably something we ought to do with it
    refs: any[];

    // Uniquely identify this object for later recall.
    unique_id: number = genUniqueID();

    constructor(parent: Profile | InspecOutput, jsonObject: any) {
        // Set the parent.
        this.parent = parent;

        // Abbreviate our param to make this all nicer looking
        let o = jsonObject;

        // Save and rename data to match what was in store
        this.code = o.code || DATA_NOT_FOUND_MESSAGE;
        this.id = o.id || DATA_NOT_FOUND_MESSAGE;
        this.impact = (o.impact === undefined) ? NUMBER_NOT_FOUND : o.impact;
        this.refs = o.refs || DATA_NOT_FOUND_MESSAGE;

        // We map results out to ControlResult s
        this.results = (o.results || []).map(
            (r: any) => new ControlResult(this, r)
        ); // Map these to results
        this.rule_title = o.title || DATA_NOT_FOUND_MESSAGE;

        // We break these out. o.source_location may be null
        this.source_file =
            (o.source_location && o.source_location.ref) ||
            DATA_NOT_FOUND_MESSAGE;
        this.source_line =
            (o.source_location && o.source_location.line) || NUMBER_NOT_FOUND;

        // We broke this into a sub-object for modularity
        this.tags = new ControlTags(this, o.tags || {});
        this.vuln_discuss = o.desc || DATA_NOT_FOUND_MESSAGE;

        // Compose our message
        this.message =
            this.impact == 0
                ? this.vuln_discuss + "\n\n"
                : DATA_NOT_FOUND_MESSAGE; // We only put the vuln discuss
        this.results.forEach(r => (this.message += r.toMessageLine()));
    }

    get vuln_num(): string {
        // We truncate the id based up to its first decimal (as far as I can tell - update later)
        if (this.id.match(/\d+\.\d+/)) {
            let match = this.vuln_num.match(/\d+(\.\d+)*/);
            if (match) {
                return match[0];
            }
        }
        return this.id;
    }

    get finding_details(): string {
        let result = "";
        switch (this.status) {
            case "Failed":
                return (
                    "One or more of the automated tests failed or was inconclusive for the control \n\n " +
                    this.message +
                    "\n"
                );
            case "Passed":
                return (
                    "All Automated tests passed for the control \n\n " +
                    this.message +
                    "\n"
                );
            case "Not Reviewed":
                return (
                    "Automated test skipped due to known accepted condition in the control : \n\n" +
                    this.message +
                    "\n"
                );
            case "Not Applicable":
                return "Justification: \n\n" + this.message + "\n";
            case "Profile Error":
                if (this.message) {
                    return "Exception: \n\n" + this.message + "\n";
                } else {
                    return "No test available for this control";
                }
            default:
                throw "Error: invalid status generated";
        }
    }

    get status(): ControlStatus {
        if (this.status_list.includes("error")) {
            return "Profile Error";
        } else {
            if (this.impact == 0) {
                return "Not Applicable";
            } else if (this.status_list.includes("failed")) {
                return "Failed";
            } else if (this.status_list.includes("passed")) {
                return "Passed";
            } else if (this.status_list.includes("skipped")) {
                return "Not Reviewed";
            } else {
                return "Profile Error";
            }
        }
    }

    get severity(): Severity {
        /* Compute the severity of this report as a string */
        if (this.impact < 0.1) {
            return "none";
        } else if (this.impact < 0.4) {
            return "low";
        } else if (this.impact < 0.7) {
            return "medium";
        } else if (this.impact < 0.9) {
            return "high";
        } else {
            return "critical";
        }
    }

    get profile_name(): string {
        /* Returns the programatically determined profile name of this control */
        let prefix;
        if (this.parent instanceof InspecOutput) {
            // It's a result - name as such
            prefix = "result;";
        } else {
            prefix = "profile;";
        }
        return prefix + this.rule_title + ": " + this.parent.version;
    }

    get start_time(): string {
        /* Returns the start time of this control's run, as determiend by the time of the first test*/
        if (this.results) {
            return this.results[0].start_time;
        } else {
            return DATA_NOT_FOUND_MESSAGE;
        }
    }

    get status_list(): ResultStatus[] {
        return this.results.map(r => r.status);
    }
}

export class ControlTags {
    /* Contains data for the tags on a Control.  */
    parent: Control;
    cci_ref: string;
    check_content: string;
    cis_family: string;
    cis_level: string;
    cis_rid: string;
    fix_text: string;
    gid: string;
    group_title: string;
    nist: string[]; // The nist categories that this control checks.
    rationale: string;
    raw_nist: string[]; // These are the nist categories as written in the file. It can sometimes contain things like "AC-16 (5)" or "Rev_4"
    rule_id: string;
    rule_ver: string;

    constructor(parent: Control, jsonObject: any) {
        // Set the parent.
        this.parent = parent;

        // Abbreviate our param to make this all nicer looking
        let o = jsonObject;

        this.cci_ref = o.cci || DATA_NOT_FOUND_MESSAGE;
        this.cis_family = o.cis_family || DATA_NOT_FOUND_MESSAGE;
        this.cis_level = o.cis_level || DATA_NOT_FOUND_MESSAGE;
        this.cis_rid = o.cis_rid || DATA_NOT_FOUND_MESSAGE;
        this.check_content = o.check || DATA_NOT_FOUND_MESSAGE;
        this.fix_text = o.fix || DATA_NOT_FOUND_MESSAGE;
        this.gid = o.gid || DATA_NOT_FOUND_MESSAGE;
        this.group_title = o.gtitle || DATA_NOT_FOUND_MESSAGE;

        // This case is slightly special as nist is usually a list. If none are provided, we just say it related to the unmapped category UM-1
        // However, nist is also sometimes a string. In such a case, wrap it in a list to be sure
        if (o.nist && typeof o.nist == "string") {
            this.raw_nist = [o.nist];
        } else {
            this.raw_nist = o.nist || ["UM-1"];
        }
        // Now we build "real" nist
        this.nist = []
        this.raw_nist.forEach(code => {
            let pattern = /^[A-Z]{2}-[0-9]+/;
            let match = code.match(pattern);
            if (match && !this.nist.includes(match[0])) {
                this.nist.push(match[0]);
            }
        });

        this.rationale = o.rationale || DATA_NOT_FOUND_MESSAGE;
        this.rule_id = o.rid || DATA_NOT_FOUND_MESSAGE;
        this.rule_ver = o.stig_id || DATA_NOT_FOUND_MESSAGE;
    }
}

export class ControlResult {
    /* Holds the results of (part of) a single control.  */
    parent: Control;
    backtrace: string;
    code_desc: string;
    exception: any;
    message: string;
    skip_message: string;
    start_time: string;
    status: ResultStatus;

    constructor(parent: Control, jsonObject: any) {
        // Set the parent.
        this.parent = parent;

        // Abbreviate our param to make this all nicer looking
        let o = jsonObject;

        // Rest we copy more or less as normal
        this.backtrace = o.backtrace || DATA_NOT_FOUND_MESSAGE;
        this.code_desc = o.code_desc || DATA_NOT_FOUND_MESSAGE;
        this.exception = o.exception || DATA_NOT_FOUND_MESSAGE;
        this.message = o.message || DATA_NOT_FOUND_MESSAGE;
        this.skip_message = o.skip_message || DATA_NOT_FOUND_MESSAGE;
        this.start_time = o.start_time || DATA_NOT_FOUND_MESSAGE;
        this.status = o.status || DATA_NOT_FOUND_MESSAGE;
    }

    toMessageLine(): string {
        switch (this.status) {
            case "skipped":
                return "SKIPPED -- " + this.skip_message + "\n";
            case "failed":
                return (
                    "FAILED -- Test: " +
                    this.code_desc +
                    "\nMessage: " +
                    this.message +
                    "\n"
                );
            case "passed":
                return "PASSED -- " + this.code_desc + "\n";
            case "error":
                return (
                    "ERROR -- Test: " +
                    this.code_desc +
                    "\nMessage: " +
                    this.message +
                    "\n"
                );
            default:
                return "Exception: " + this.exception + "\n";
        }
    }
}

export class Group {
    /* Contains information regarding the grouping of a controls within a profile */

    parent: Profile;
    title: string;
    controls: string[];
    id: string;

    constructor(parent: Profile, jsonObject: any) {
        // Set the parent.
        this.parent = parent;

        // Abbreviate our param to make this all nicer looking
        let o = jsonObject;

        this.title = o.title || DATA_NOT_FOUND_MESSAGE;
        this.controls = o.controls || [];
        this.id = o.id || DATA_NOT_FOUND_MESSAGE;
    }

    // TODO: Make a function to grab the actual controls via routing thru parent
}

export class Attribute {
    /* Contains further information about a profile*/

    parent: Profile;
    name: string;
    options_description: string;
    options_default: string;

    constructor(parent: Profile, jsonObject: any) {
        // Set the parent. Would be of type Profile
        this.parent = parent;

        // Abbreviate our param to make this all nicer looking
        let o = jsonObject;

        // Extract rest from json
        this.name = o.name;
        if (o.options) {
            this.options_description =
                o.options.description || DATA_NOT_FOUND_MESSAGE;
            this.options_default = o.options.default || DATA_NOT_FOUND_MESSAGE;
        } else {
            this.options_description = DATA_NOT_FOUND_MESSAGE;
            this.options_default = DATA_NOT_FOUND_MESSAGE;
        }
    }
}
